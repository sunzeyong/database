# 什么是索引
为了提高查询速度设计的数据结构

# innodb索引分类

## 数据存储
1. 聚簇索引
2. 非聚簇索引（二级索引）

## 字段个数
1. 单列索引
2. 联合索引

## 字段特性
1. 主键索引
2. 唯一索引
3. 前缀索引
4. 普通索引

## 数据结构
1. B+树索引
2. Hash索引
3. 全文索引

# 适用场景和注意事项
建立索引需要综合考虑适合建立索引和不适合建立索引情况

## 适合建索引情况
1. 经常用于 WHERE 查询条件的字段，如果查询条件不是一个字段，可以建立联合索引。
2. 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了。

## 不适合建索引情况
1. 字段中存在大量重复数据
2. 表数据太少的时候
3. 经常更新的字段不用创建索引

# 索引优化方法

## 前缀索引优化
使用某个字段中字符串的前几个字符建立索引  
优点：
1. 了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。

缺点：
1. order by 就无法使用前缀索引
2. 无法把前缀索引用作覆盖索引

## 索引覆盖优化
覆盖索引是指SQL中query的所有字段，都能从二级索引中查询得到，这就叫索引覆盖。  
因为不需要通过聚簇索引查询获得字段，可以避免回表的操作，减少了大量的 I/O 操作。

## 主键最好自增
1. 插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
2. 非自增会导致页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。

## 索引设置notnull
1. 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化
2. NULL 值是一个没意义的值，但是它会占用物理空间。

## 查询时防止索引失效
参考索引失效情况

# 索引失效情况

## 使用左或者左右模糊匹配
why: 因为索引B+树是按照索引值有序排列存储的，只能根据前缀进行比较。

## 对索引列使用函数
why: 索引保存的是索引字段的原始值，而不是经过函数计算后的值

## 对索引使用表达式
why: 原因跟对索引使用函数差不多，索引保存的是原始值，而不是表达式计算后的值

## 对索引进行隐式类型转换
why: MySQL在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果索引是字符串，查询语句会自动将索引列加上类型转换，导致无法使用索引

## 联合索引非最左匹配
why: 联合索引的定义导致非最左匹配时无法使用索引

**索引下推** 
从 MySQL 5.6之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

## where子句中有or
why: 因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。


